#!/usr/bin/env python3
"""
Local Network Port Scanner
Scans the local network for specific open ports and identifies services.
"""

import socket
import ipaddress
import concurrent.futures
from typing import List, Dict, Tuple
import subprocess
import platform

# Define ports and their services
PORTS = {
    22: "SSH",
    23: "TELNET",
    80: "HTTP",
    443: "HTTPS",
    1255: "HEOS",
    4352: "PJLINK",
    9009: "LIGHTS",
    10000: "KALEIDESCAPE"
}

def get_local_network() -> str:
    """Get the local network CIDR."""
    try:
        # Get local IP address
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()

        # Assume /24 subnet
        network = '.'.join(local_ip.split('.')[:-1]) + '.0/24'
        return network
    except Exception as e:
        print(f"Error getting local network: {e}")
        return "192.168.1.0/24"  # Default fallback

def get_hostname(ip: str, timeout: float = 2.0) -> str:
    """Attempt to get the hostname for an IP address using multiple methods."""

    # Method 1: Standard DNS reverse lookup
    try:
        hostname = socket.gethostbyaddr(ip)[0]
        if hostname and hostname != ip:
            return hostname
    except:
        pass

    # Method 2: mDNS/Bonjour lookup (works well for Raspberry Pi and Apple devices)
    try:
        result = subprocess.run(
            ['avahi-resolve', '-a', ip],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        if result.returncode == 0:
            # Output format: "192.168.1.196	hostname.local"
            parts = result.stdout.strip().split()
            if len(parts) >= 2:
                hostname = parts[1].replace('.local', '')
                return hostname
    except:
        pass

    # Method 3: Try SNMP sysName (if snmpget is available)
    try:
        result = subprocess.run(
            ['snmpget', '-v2c', '-c', 'public', ip, 'sysName.0'],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        if 'STRING:' in result.stdout:
            name = result.stdout.split('STRING:')[1].strip().strip('"')
            if name:
                return name
    except:
        pass

    # Method 4: nmblookup on Linux/Mac (NetBIOS)
    if platform.system() != "Windows":
        try:
            result = subprocess.run(
                ['nmblookup', '-A', ip],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            for line in result.stdout.split('\n'):
                if '<00>' in line and 'GROUP' not in line:
                    name = line.split()[0].strip()
                    if name and name != ip:
                        return name
        except:
            pass

    # Method 5: nbtstat on Windows (NetBIOS)
    if platform.system() == "Windows":
        try:
            result = subprocess.run(
                ['nbtstat', '-A', ip],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            for line in result.stdout.split('\n'):
                if '<00>' in line and 'UNIQUE' in line:
                    name = line.split()[0].strip()
                    if name:
                        return name
        except:
            pass

    # Method 6: Try SSH banner grab (for devices with SSH open)
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((ip, 22))
        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
        sock.close()
        # SSH banner often contains hostname
        if banner:
            # Extract anything that looks like a hostname from the banner
            parts = banner.split()
            for part in parts:
                if '.' in part or '-' in part:
                    # Clean up the hostname
                    cleaned = part.strip('()[]').split()[0]
                    if len(cleaned) > 2 and cleaned != ip:
                        return f"{cleaned} (SSH)"
    except:
        pass

    return "Unknown"

def check_port(ip: str, port: int, timeout: float = 1.0) -> bool:
    """Check if a specific port is open on the given IP."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        return result == 0
    except:
        return False

def scan_host(ip: str) -> Dict:
    """Scan a single host for all specified ports."""
    open_ports = []

    for port in PORTS.keys():
        if check_port(ip, port):
            open_ports.append(port)

    if open_ports:
        hostname = get_hostname(ip)
        return {
            'ip': ip,
            'hostname': hostname,
            'open_ports': open_ports
        }

    return None

def scan_network(network: str, max_workers: int = 50) -> List[Dict]:
    """Scan the entire network for open ports."""
    results = []
    network_obj = ipaddress.IPv4Network(network, strict=False)

    print(f"Scanning network: {network}")
    print(f"Total hosts to scan: {network_obj.num_addresses - 2}")
    print("This may take a few minutes...\n")

    # Use ThreadPoolExecutor for concurrent scanning
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Skip network and broadcast addresses
        hosts = [str(ip) for ip in network_obj.hosts()]

        # Submit all scan jobs
        future_to_ip = {executor.submit(scan_host, ip): ip for ip in hosts}

        # Process completed scans
        completed = 0
        for future in concurrent.futures.as_completed(future_to_ip):
            completed += 1
            if completed % 10 == 0:
                print(f"Scanned {completed}/{len(hosts)} hosts...", end='\r')

            result = future.result()
            if result:
                results.append(result)

    print(f"\nScan complete! Found {len(results)} hosts with open ports.\n")
    return results

def print_results(results: List[Dict]):
    """Print the scan results in a formatted way."""
    if not results:
        print("No hosts found with specified ports open.")
        return

    print("=" * 80)
    print(f"{'IP Address':<18} {'Hostname':<25} {'Open Services'}")
    print("=" * 80)

    for host in sorted(results, key=lambda x: ipaddress.IPv4Address(x['ip'])):
        services = [f"{PORTS[port]} ({port})" for port in host['open_ports']]
        services_str = ", ".join(services)

        print(f"{host['ip']:<18} {host['hostname']:<25} {services_str}")

    print("=" * 80)

def main():
    """Main function to run the network scanner."""
    print("Local Network Port Scanner")
    print("=" * 80)

    # Get local network
    network = get_local_network()
    print(f"Detected network: {network}")

    # Allow user to override
    user_input = input(f"Press Enter to use this network, or enter a different CIDR (e.g., 192.168.1.0/24): ").strip()
    if user_input:
        network = user_input

    print()

    # Scan the network
    results = scan_network(network)

    # Print results
    print_results(results)

if __name__ == "__main__":
    main()
